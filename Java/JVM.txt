java优点
跨平台
为什么跨平台？c,c++跨平台吗？
    c,c++是编译器层面兼容不同系统的实现，不同操作系统代码有差别。
    编译成class文件，屏蔽了硬件，操作系统细节。

JRE JVM JDK
JRE Java Runtime Environment 运行类库  Java编译器将.java文件变成.class文件
JRE包含JVM，类库，类装载器
JDK Java Development Kit 软件开发包。
JVM Java解释器和及时编译器 运行期系统
没有JDK的话，无法编译Java程序（指java源码.java文件），如果想只运行Java程序（指class或jar或其它归档文件），要确保已安装相应的JRE。

运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，
然后将之编译成字节码(.class文件)，再然后字节码被装入内存，
一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行

Java为什么霸占企业级开发多年？并且多年第一？
    内存管理！！！
    专注在业务上，简单易上手。

如果出现内存溢出等问题？
    需要学习JVM内存管理

CPU调度策略
    时间片   挂起，唤醒

内存
    高速缓存区，cpu和存储的交互

但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存

CPU的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作

基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。
在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，main memory 主要内存），
当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。
为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。
这类协议包括MSI、MESI、MOSI、Synapse、Firely、DragonProtocol等。

虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！

多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当
线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码+操作数）

JVM运行时数据区 JVM.png  分数据  指令
    程序计数器 指向当前线程正在执行的字节码指令的地址（行号）
          字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
        分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成

          由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现
        的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行
        一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要
        有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内
        存区域为“线程私有”的内存。

        如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节
        码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此
        内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域

    一个方法一个栈帧
    虚拟机栈 FILO存储当前线程运行方法运行所需的数据，指令，返回地址
        局部变量表   存局部变量
        操作数栈
        动态链接     如多态
        出口         return 出栈

        递归会溢出

          Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。
        虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）
        用于存储局部变量表、操作栈、动态链接、方法出口等信息。

          局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、
        float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟
        机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或
        者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。
        其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余
        的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个
        方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间
        不会改变局部变量表的大小。
          在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大
        于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展
        当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的
        虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常

    本地方法栈  如System 的native方法
          本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其
        区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则
        是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语
        言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至
        有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。
        与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError
        异常。

    堆  成员变量存堆
          对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的
        一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的
        唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
          Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。
        如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，
        所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。
        如果从内存分配、的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local
        Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，
        存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

    方法区
        <=1.6
        >1.6
        方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存
        储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽
        然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-
        Heap（非堆），目的应该是与Java 堆区分开来。

        当方法区无法满足内存分配需求时，将抛出OutOfMemryError 异常。

    运行时常量池
          运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有
        类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），
        用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放
        到方法区的运行时常量池中。
          运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语
        言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容
        才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发
        人员利用得比较多的便是String 类的intern() 方法
          既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无
        法再申请到内存时会抛出OutOfMemoryError 异常

1）堆内存（heap）
操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，
另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。
但由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
这时由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不是在堆，也不是在栈，而是直接在进程的地址空间中保留一块内存，虽然这种方法用起来最不方便，但是速度快，也是最灵活的。
堆内存是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。
由此可见，堆获得的空间比较灵活，也比较大

2）栈内存（stack）
栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，
在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。
因此，能从栈获得的空间较小。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 由系统自动分配，速度较快

基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。
引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量 。
方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。
局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。
方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈空间收回。字符串常量、static在DATA区域分配，this在堆空间分配。
数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小。

3）本地方法栈（java中的jni调用）

用于支持native方法的执行，存储了每个native方法调用的状态。对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。
Sun公司实现Java本地接口(JNI)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。
但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。

4）方法区（method）

它保存方法代码(编译后的java代码)和符号表。存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。
JVM用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。


Object obj = new Object();
假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈
的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义
将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对
象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布
局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中
还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地
址信息，这些类型数据则存储在方法区中。
  由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有
定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此
不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。
  如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference
中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的
具体地址信息，
  如果使用直接指针访问方式，
Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，如对象类型数据存在方法区，reference 中直接存储的就是对象地址


示例
1、Java 堆溢出
    我们限制Java 堆的大小为20MB，不可扩展（将堆的最小值-Xms 参
数与最大值-Xmx 参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDump
OnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储
快照以便事后进行分析。
    出现Java 堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap
space”。
    要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse
Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是
否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢
出（Memory Overflow）。
    如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就
能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收
它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确
地定位出泄漏代码的位置。
    如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查
虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上
检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期
的内存消耗。

2、java栈溢出
    常见的如递归

3、常量池溢出

4、方法区溢出

5、直接内存溢出


